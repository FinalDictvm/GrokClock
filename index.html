<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Event Clock</title>
    <style>
        body {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        /* Clock container */
        .clock {
            position: relative;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }

        /* Season overlay */
        .season-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
            background: conic-gradient(
                rgba(255, 182, 193, 0.3) 0deg 90deg,    /* Spring */
                rgba(255, 255, 153, 0.3) 90deg 180deg,  /* Summer */
                rgba(240, 128, 128, 0.3) 180deg 270deg, /* Fall */
                rgba(173, 216, 230, 0.3) 270deg 360deg  /* Winter */
            );
        }

        /* Markers */
        .marker {
            position: absolute;
            width: 20px;
            height: 20px;
            z-index: 2;
            cursor: pointer;
        }

        .major-holiday-dot,
        .minor-holiday-dot,
        .birthday-dot,
        .custom-dot,
        .life-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            border-radius: 50%;
            border: 1px solid white;
            transition: transform 0.2s ease;
        }

        /* Colors for each dot type */
        .major-holiday-dot { background: rgb(255, 0, 0); }
        .minor-holiday-dot { background: rgb(255, 165, 0); }
        .birthday-dot { background: rgb(255, 8, 201); }
        .custom-dot { background: rgb(4, 255, 0); }
        .life-dot { background: rgb(13, 126, 255); }

        /* Hover effect: Dot grows */
        .active .major-holiday-dot,
        .active .minor-holiday-dot,
        .active .birthday-dot,
        .active .custom-dot,
        .active .life-dot {
            transform: translate(-50%, -50%) scale(2);
        }

        /* Arcs for date range events */
        .arcs path {
            transition: stroke-width 0.2s ease;
        }

        /* Display panel */
        #display {
            width: 300px;
            height: 300px;
            background: white;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            overflow-y: auto;
            font-size: 16px;
        }

        .event-date {
            color: gray;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="clock" id="clock">
        <div class="season-overlay" id="seasonOverlay"></div>
        <!-- SVG for arcs, placed after season-overlay so arcs appear above it -->
        <svg class="arcs" width="300" height="300" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1;"></svg>
    </div>
    <div id="display">Hover over an event to see details</div>

    <script>
        // Constants
        const centerX = 150; // Center of the clock (300px / 2)
        const centerY = 150;
        const typePriority = ["major-holiday", "minor-holiday", "life", "birthday", "custom"];
        const events = new Map(); // Store events with start/end markers and arcs
        let eventCounter = 0; // Unique ID counter for events

        // DOM elements
        const clock = document.getElementById("clock");
        const display = document.getElementById("display");

        // Helper to format dates (e.g., "January 1st")
        function formatDate(month, day) {
            const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            return `${monthNames[month - 1]} ${day}${getDaySuffix(day)}`;
        }

        // Add suffixes like "st", "nd", "rd", "th"
        function getDaySuffix(day) {
            if (day >= 11 && day <= 13) return "th";
            switch (day % 10) {
                case 1: return "st";
                case 2: return "nd";
                case 3: return "rd";
                default: return "th";
            }
        }

        // Create a marker for an event
        function createMarker(data, type, eventId) {
            const container = document.createElement("div");
            container.className = `marker ${type}-marker`;
            const dot = document.createElement("div");
            dot.className = `${type}-dot`;
            container.appendChild(dot);

            // Calculate angle based on month and day
            const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            const totalDays = daysInMonth.reduce((a, b) => a + b, 0);
            let elapsedDays = daysInMonth.slice(0, data.month - 1).reduce((a, b) => a + b, 0) + (data.day - 1);
            const angle = (elapsedDays / totalDays) * 360;

            // Set data attributes
            container.dataset.type = type;
            container.dataset.name = data.name;
            container.dataset.month = data.month;
            container.dataset.day = data.day;
            container.dataset.date = formatDate(data.month, data.day);
            container.dataset.order = eventCounter; // For sorting ties
            container.dataset.angle = angle;
            if (eventId) container.dataset.eventId = eventId;

            clock.appendChild(container);
            return container;
        }

        // Create an arc between start and end markers for date range events
        function createArc(startMarker, endMarker, type) {
            const svg = document.querySelector('.arcs');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const startAngle = parseFloat(startMarker.dataset.angle);
            const endAngle = parseFloat(endMarker.dataset.angle);
            const radius = 160; // Base radius, fixed to circumference
            const startRadian = (startAngle - 90) * Math.PI / 180;
            const endRadian = (endAngle - 90) * Math.PI / 180;
            const startX = centerX + radius * Math.cos(startRadian);
            const startY = centerY + radius * Math.sin(startRadian);
            const endX = centerX + radius * Math.cos(endRadian);
            const endY = centerY + radius * Math.sin(endRadian);
            const delta = (endAngle - startAngle + 360) % 360;
            const largeArcFlag = delta > 180 ? 1 : 0;
            const pathD = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`;
            
            path.setAttribute('d', pathD);
            path.setAttribute('stroke', getColorForType(type));
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            svg.appendChild(path);
            return path;
        }

        // Get color for arc based on event type
        function getColorForType(type) {
            switch (type) {
                case 'major-holiday': return 'rgb(255, 0, 0)';
                case 'minor-holiday': return 'rgb(255, 165, 0)';
                case 'birthday': return 'rgb(255, 8, 201)';
                case 'custom': return 'rgb(4, 255, 0)';
                case 'life': return 'rgb(13, 126, 255)';
                default: return 'black';
            }
        }

        // Check if a marker is part of a date range event (has an end marker)
        function isDateRangeMarker(marker) {
            const eventId = marker.dataset.eventId;
            if (!eventId) return false;
            const event = events.get(eventId);
            return !!event.endMarker; // True if the event has an endMarker
        }

        // Update positions of all dots, handling stacking with date range priority
        function updateAllDotPositions() {
            const dateToVisibleDots = {};
            const markers = clock.querySelectorAll(".marker");
            
            // Group markers by date (month-day)
            markers.forEach(marker => {
                if (marker.style.display !== "none") {
                    const dateKey = `${marker.dataset.month}-${marker.dataset.day}`;
                    if (!dateToVisibleDots[dateKey]) dateToVisibleDots[dateKey] = [];
                    dateToVisibleDots[dateKey].push(marker);
                }
            });

            // For each date, sort and position markers
            Object.keys(dateToVisibleDots).forEach(dateKey => {
                const dots = dateToVisibleDots[dateKey];

                // Sort markers:
                // 1. Date range markers (start/end of life events with endMarker) come first
                // 2. Within each group, sort by typePriority
                // 3. Then by name, then by creation order
                dots.sort((a, b) => {
                    const aIsDateRange = isDateRangeMarker(a);
                    const bIsDateRange = isDateRangeMarker(b);
                    
                    // Date range markers get lowest slots (innermost positions)
                    if (aIsDateRange && !bIsDateRange) return -1;
                    if (!aIsDateRange && bIsDateRange) return 1;

                    // If both are date range or both are not, sort by type priority
                    const typeA = a.dataset.type;
                    const typeB = b.dataset.type;
                    const priorityA = typePriority.indexOf(typeA);
                    const priorityB = typePriority.indexOf(typeB);
                    if (priorityA !== priorityB) return priorityA - priorityB;

                    // Tiebreaker: alphabetical by name
                    const nameA = a.dataset.name;
                    const nameB = b.dataset.name;
                    if (nameA !== nameB) return nameA.localeCompare(nameB);

                    // Final tiebreaker: creation order
                    return Number(a.dataset.order) - Number(b.dataset.order);
                });

                // Position markers, stacking outward from base radius
                dots.forEach((dot, index) => {
                    const angle = parseFloat(dot.dataset.angle);
                    const radian = (angle - 90) * Math.PI / 180;
                    const radius = 160 + index * 4; // Base radius + 4px per stack level
                    const markerCenterX = centerX + radius * Math.cos(radian);
                    const markerCenterY = centerY + radius * Math.sin(radian);
                    // Marker is 20x20px, so offset by half to center it
                    dot.style.left = `${markerCenterX - 10}px`;
                    dot.style.top = `${markerCenterY - 10}px`;
                });
            });
        }

        // Fetch birthdays (no end dates expected)
        async function fetchBirthdays() {
            // Simulated data (replace with actual fetch if using a spreadsheet)
            return [
                { name: "Alice", month: 1, day: 15, year: 1990 },
                { name: "Bob", month: 6, day: 20, year: 1985 }
            ];
        }

        // Fetch life events (supports end dates)
        async function fetchLifeEvents() {
            // Simulated data (replace with actual fetch if using a spreadsheet)
            return [
                { name: "College", month: 9, day: 1, year: 2008, endMonth: 5, endDay: 15, endYear: 2012 },
                { name: "Job Start", month: 6, day: 1, year: 2012 }
            ];
        }

        // Load data and create markers
        fetchBirthdays().then(birthdays => {
            birthdays.forEach(b => {
                const eventId = `birthday-${eventCounter++}`;
                const startData = { name: b.name, month: b.month, day: b.day, year: b.year };
                const startMarker = createMarker(startData, "birthday", eventId);
                // Birthdays have no end dates, so store as single marker event
                events.set(eventId, { type: "birthday", name: b.name, startMarker });
            });
            updateAllDotPositions();
        });

        fetchLifeEvents().then(lifeEvents => {
            lifeEvents.forEach(e => {
                const eventId = `life-${eventCounter++}`;
                const startData = { name: e.name, month: e.month, day: e.day, year: e.year };
                const startMarker = createMarker(startData, "life", eventId);
                
                if (e.endMonth && e.endDay) {
                    const endData = { name: e.name, month: e.endMonth, day: e.endDay, year: e.endYear };
                    const endMarker = createMarker(endData, "life", eventId);
                    const arc = createArc(startMarker, endMarker, "life");
                    // Store date range event with both markers and arc
                    events.set(eventId, { type: "life", name: e.name, startMarker, endMarker, arc });
                } else {
                    // Single-dot life event
                    events.set(eventId, { type: "life", name: e.name, startMarker });
                }
            });
            updateAllDotPositions();
        });

        // Mouse move event for hover effects
        clock.addEventListener("mousemove", (e) => {
            const markers = clock.querySelectorAll(".marker");
            let closestMarker = null;
            let minDistance = Infinity;

            // Reset all markers and arcs
            markers.forEach(m => m.classList.remove('active'));
            events.forEach(event => {
                if (event.arc) event.arc.setAttribute('stroke-width', '2');
            });

            // Find closest marker to mouse
            markers.forEach(marker => {
                const rect = marker.getBoundingClientRect();
                const markerX = rect.left + rect.width / 2;
                const markerY = rect.top + rect.height / 2;
                const distance = Math.hypot(e.clientX - markerX, e.clientY - markerY);
                if (distance < minDistance && distance < 20) { // Threshold of 20px
                    minDistance = distance;
                    closestMarker = marker;
                }
            });

            if (closestMarker) {
                const eventId = closestMarker.dataset.eventId;
                if (eventId && events.has(eventId)) {
                    const event = events.get(eventId);
                    const eventMarkers = [event.startMarker];
                    if (event.endMarker) eventMarkers.push(event.endMarker);
                    eventMarkers.forEach(m => m.classList.add('active'));
                    if (event.arc) event.arc.setAttribute('stroke-width', '3');

                    // Display date range or single date
                    let dateText;
                    if (event.endMarker) {
                        const startDate = formatDate(event.startMarker.dataset.month, event.startMarker.dataset.day);
                        const endDate = formatDate(event.endMarker.dataset.month, event.endMarker.dataset.day);
                        dateText = `${startDate} to ${endDate}`;
                    } else {
                        dateText = event.startMarker.dataset.date;
                    }
                    display.innerHTML = `${event.name}<br><span class='event-date'>${dateText}</span>`;
                } else {
                    // Single marker without event pairing
                    display.innerHTML = `${closestMarker.dataset.name}<br><span class='event-date'>${closestMarker.dataset.date}</span>`;
                    closestMarker.classList.add('active');
                }
            } else {
                display.innerHTML = "Hover over an event to see details";
            }
        });
    </script>
</body>
</html>
